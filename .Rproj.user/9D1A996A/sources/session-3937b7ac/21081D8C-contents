---
title: "**Qualidade da Ãgua Superficial no Brasil**"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE, warning = FALSE, results='asis')

## instruÃ§Ãµes para publicaÃ§Ã£o no github: https://youtu.be/0GjUWgl03vA

#git >- more >- shell >- git add . >- git commit -m "xxx built" .
#https://github.com/souzademarcelo/Qualidade_da_Agua_2023.github.io.git

```


```{r packs, echo=FALSE, warning=FALSE, results='hide', message=FALSE}
library(dplyr)
library(tidyr)
library(RPostgreSQL)
library(ggplot2)
library(lubridate)
library(htmltools)
library(rsconnect)
library(shinyWidgets)
library(nortest)
library(DBI)
library(NADA)
library(readr)
library(tidyverse)
library(sf)
library(mapview)
library(Hmisc)
library(knitr)
library(kableExtra)
library(htmlwidgets)
library(sp)
library(lattice)
library(leafpop)
library(shapefiles) 
library(st)
#library(rgdal) retired package
```


```{r, echo=FALSE}


drv<- dbDriver("PostgreSQL")
con <- dbConnect(drv, dbname = "qa_v01_16_local", 
                 host = "localhost", port = 5432,
                 user = "postgres", password ="postgres" )

parametro <- 'od'
parametro_abreviado <- "OD"
parametro_extenso <- "OxigÃªnio Dissolvido na Ã¡gua"

serie_ini <- as.Date('2010-01-01', format = "%Y-%m-%d")
serie_final <- as.Date('2023-12-31', format = "%Y-%m-%d")

# Extrai os anos das datas
ini <- substr(serie_ini, 1, 4)
final <- substr(serie_final, 1, 4)

```

<br>  

### **Qualidade da Ãgua**

A qualidade da Ã¡gua nos corpos hÃ­dricos Ã© determinada pelas condiÃ§Ãµes naturais e aÃ§Ãµes humanas praticadas na bacia hidrogrÃ¡fica. Entre os fatores naturais que influenciam a qualidade da Ã¡gua em rios e lagos estÃ£o:    

- A dissoluÃ§Ã£o de minerais presentes no solo e subsolo em funÃ§Ã£o do intemperismo;   
- Processos atmosfÃ©ricos de evapotranspiraÃ§Ã£o e deposiÃ§Ã£o de partÃ­culas carreadas pelo vento;    
- DecomposiÃ§Ã£o da matÃ©ria orgÃ¢nica e lixiviaÃ§Ã£o natural de nutrientes;    
- Fatores hidrolÃ³gicos ligados ao regime de escoamento; e processos biolÃ³gicos que alteram a composiÃ§Ã£o fÃ­sica e quÃ­mica da Ã¡gua. 
    


```{r fig_poluicao,   out.width='55%', out.extra='style="float:right; padding:10px"', echo = FALSE}

knitr::include_graphics("poluicao.jpg")

```


Atualmente as aÃ§Ãµes humanas tÃªm sido apontadas como a principal causa da degradaÃ§Ã£o da qualidade da Ã¡gua que usamos para os mais diversos fins. Das volumosas cargas de efluentes e lixo despejadas nos rios e lagos aos invisÃ­veis micropoluentes e agentes quÃ­micos que ameaÃ§am a saÃºde dos seres vivos, somos responsÃ¡veis por uma ampla variedade de poluentes que se acumulam em nossas Ã¡guas todos os dias. 

Entre os principais contaminantes da Ã¡gua, destacam-se:    

- MatÃ©ria orgÃ¢nica e outros compostos que consomem oxigÃªnio em sua degradaÃ§Ã£o;
- Microrganismos causadores de doenÃ§as (patÃ³genos);    
- Nutrientes, principalmente fÃ³sforo e nitrogÃªnio;     
- Metais pesados;     
- Compostos orgÃ¢nicos presentes em pesticidas;    
- Micropoluentes, como disruptores endÃ³crinos e microplÃ¡sticos.    

<br>

### **Monitoramento da Qualidade da Ãgua nos Rios**
      
  
O monitoramento da qualidade da Ã¡gua consiste basicamente na obtenÃ§Ã£o de informaÃ§Ãµes quantitativas e representativas sobre as caracterÃ­sticas fÃ­sicas, quÃ­micas e biolÃ³gicas da Ã¡gua em determinados trechos de um corpo hÃ­drico ao longo do tempo. Os dados resultantes do monitoramento permitem avaliar a adequaÃ§Ã£o da Ã¡gua para diversos usos com base em parÃ¢metros de qualidade e valores de referÃªncia.
   

<br>

#### **Redes de Monitoramento no Brasil**
```{r fig_monitoramento, out.width='31%', out.extra='style="float:right; padding:10px"', echo = FALSE}

knitr::include_graphics("monitoramento_horizontal.jpg")

```
 
As principais redes de monitoramento da qualidade de Ã¡gua dos rios brasileiros sÃ£o operadas por Ã³rgÃ£os governamentais responsÃ¡veis pela gestÃ£o ambiental e dos recursos hÃ­dricos nas Unidades da FederaÃ§Ã£o (UFs). O mapa abaixo mostra as UFs que operam estas redes no Brasil e a quantidade de pontos de monitoramento com dados de qualidade da Ã¡gua em nossa base no perÃ­odo de 2010 a 2021. 

<div style= "float:center;position: relative; top: 0px">

</div>

Estas redes estÃ£o sendo integradas Ã  Rede Nacional de Monitoramento de Qualidade das Ãguas (RNQA), criada em 2013 pela ANA depois de ampla discussÃ£o com as UFs sobre seu escopo, funcionamento e sustentabilidade financeira. A expansÃ£o destas redes a todas UFs Ã© prevista segundo critÃ©rios do projeto da RNQA. SÃ£o objetivos da RNQA:   

- Analisar a tendÃªncia de evoluÃ§Ã£o da qualidade das Ã¡guas superficiais;
- Avaliar se a qualidade atual das Ã¡guas atende os usos estabelecidos pelo seu enquadramento;
- Identificar Ã¡reas crÃ­ticas com relaÃ§Ã£o Ã  poluiÃ§Ã£o hÃ­drica;
- Aferir a efetividade da gestÃ£o sobre as aÃ§Ãµes de recuperaÃ§Ã£o da qualidade das Ã¡guas superficiais;
- Apoiar as aÃ§Ãµes de planejamento, outorga, licenciamento e fiscalizaÃ§Ã£o.

<br>
    
```{r pontos_uf,  echo=FALSE, warning=FALSE, message=FALSE, out.width = '100%'}
options(OutDec=",", digits = "2")
#knitr::include_graphics("pontos_uf.png")

parametro_sql <- paste("SELECT codigo, data,  ", parametro, "  as valor, ", parametro, "_st as status FROM pgquali.qlttb_2_par_", parametro, " where ", parametro, "_st in (1,2) ORDER BY codigo", sep = "")
  tbl <- dbGetQuery(con, parametro_sql)

# Filtra para o perÃ­odo e valores impossÃ­veis (OD<18 mg/L) segundo a referÃªncia: Readings above 18 mg/l are physically impossible at Earthâ€™s surface: https://www.knowyourh2o.com/outdoor-4/dissolved-oxygen-in-water
tbl <- tbl %>%
  filter(data >= serie_ini & data <= serie_final, 
         valor < 18)

# Contagem dos pontos
ponto_obs <- length(unique(tbl$codigo))
# Contagem das observaÃ§Ãµes no perÃ­odo
parametro_obs <- length(tbl$valor)

# Importa tabela de pontos
pontos_sql <- paste("SELECT codigo, uf, latitude, longitude, enquadramento, corpo_hidrico FROM pgquali.qltft_1_pontos ORDER BY uf, codigo;", sep = "")
pontos <- dbGetQuery(con, pontos_sql)
coordenadas <- data.frame(
  codigo = c(pontos$codigo),
  UF = c(pontos$uf),
  lon = c(pontos$longitude[!is.na(pontos$longitude)]),
  lat = c(pontos$latitude[!is.na(pontos$latitude)]),
  classe = c(pontos$enquadramento),
  rio = c(pontos$corpo_hidrico),
  stringsAsFactors = FALSE)

# cria coluna com valor (0/1) apontando desconformidade dom a classe 2)
tbl <- tbl %>%
   mutate(desc2 = case_when(valor <=5 ~ 1, valor > 5 ~ 0))

# estatÃ­stcas e desconformidadade com a classe 2 
grouped_obs <- tbl %>%
    group_by(codigo) %>%
    summarise(n=n(), mÃ©dia=mean(valor), desconformidade = (sum(desc2)/n*100), inÃ­cio=min(data), final=max(data)) 

# Join tabela de observaÃ§Ãµes com a de pontos
grouped_obs <- left_join(grouped_obs, coordenadas, by = c("codigo" = "codigo"))
grouped_obs <- na.omit(grouped_obs)

# Conta o nÃºmero de pontos com registro de OD no perÃ­odo analisado
obs_uf <- grouped_obs %>%
  group_by(UF) %>%
    summarise(n = n(),.groups = 'drop') %>%
    rename(Pontos = n)

# importando o shape da pasta BR_UF_2022 no diretÃ³rio de trabalho
## o pacote RGDAL foi aposentado e por isso readOGR nÃ£o vai funcionar. O pacote sf e a funÃ§Ã£o read_sf Ã© a alternativa
#shp <- readOGR("BR_UF_2022\\.", "BR_UF_2022", stringsAsFactors=FALSE, encoding="UTF-8", verbose = FALSE) 
shp <- read_sf("BR_UF_2022/BR_UF_2022.shp") 

# Une o shape das UFs com o DF contendo o nÃºmero de pontos por UF 
obs_uf_shp <- merge(shp,obs_uf, by.x = "SIGLA_UF", by.y = "UF")

# proj4string(obs_uf_shp) <- CRS("+proj=longlat +datum=WGS84 +no_defs")
# 
# Encoding(obs_uf_shp$NM_UF) <- "UTF-8"

state_popup <- paste0("<strong>Estado: </strong>", obs_uf_shp$NM_UF)

# obs_uf_shp$Score[is.na(obs_uf_shp$Pontos)] <- 0

obs_uf_shp <- na.omit(obs_uf_shp)

# renomeia coluna NM_UF para Estado
names(obs_uf_shp)[names(obs_uf_shp) == "NM_UF"] <- "UF"

# pal <-  mapviewPalette("mapviewSpectralColors")
# mapview(obs_uf_shp["Pontos"], popup = popupTable(obs_uf_shp, zcol= c("Pontos", "UF"), row.numbers=FALSE, feature.id=FALSE),
#         at = seq(1,800,100),
#         map.types = c("CartoDB.Positron", "Esri.WorldImagery"), 
#         # cex = 3, # tamanho dos markers 
#         # lwd = 0.2, #espessura da linha dos markers
#         alpha.regions = 100, #opacidade dos markers
#         legend = TRUE, 
#       #  col.regions = (pal (30)),
#         layer.name = "Monitoramento nas UFs")
pal <-  mapviewPalette("mapviewSpectralColors")
mapview(obs_uf_shp["Pontos"], popup = popupTable(obs_uf_shp, zcol= c("UF", "Pontos"), row.numbers=FALSE, feature.id=FALSE),
layer.name = "NÃºmero de Pontos de Monitoramento nas UFs",  
at = seq(1,900,100),
legend = TRUE, 
alpha.regions = 0.5)

```
    


<br>

### **Monitoramento e Enquadramento**


O monitoramento tem a importante funÃ§Ã£o de apontar Ã¡reas prioritÃ¡rias para aÃ§Ãµes de controle da poluiÃ§Ã£o da Ã¡gua e tendÃªncias na qualidade da Ã¡gua ao longo do tempo. Os dados do monitoramento tambÃ©m revelam se a Ã¡gua dos rios apresenta qualidade compatÃ­vel com os usos a que se destina. Esta Ã©, portanto, uma atividade aliada Ã  implementaÃ§Ã£o dos instrumentos de gestÃ£o de recursos hÃ­dricos, especialmente o enquadramento dos corpos hÃ­dricos em classes de qualidade segundo os usos preponderantes da Ã¡gua.


```{r fig_enquadramento, out.width='45%', out.extra='style="float:right; padding:10px"', echo = FALSE}

knitr::include_graphics("enquadramento.jpg")

```


O enquadramento de corpos de Ã¡gua em classes Ã© um instrumento da PolÃ­tica Nacional de Recursos HÃ­dricos (Lei Federal nÂº 9.433/1997) que busca estabelecer um nÃ­vel de qualidade da Ã¡gua em um determinado trecho rio que seja adequado aos seus usos preponderantes, atuais ou pretendidos. O conceito por trÃ¡s do instrumento Ã© estabelecer para as Ã¡guas brutas padrÃµes de qualidade a serem mantidos ou metas a serem perseguidas por meio das aÃ§Ãµes de gestÃ£o da qualidade da Ã¡gua.


A ResoluÃ§Ã£o CONAMA nÂº 357/2005 estabelece um sistema de classificaÃ§Ã£o em que, para cada classe, hÃ¡ possÃ­veis destinaÃ§Ãµes de usos e um conjunto de condiÃ§Ãµes e padrÃµes de qualidade a serem cumpridos com base em parÃ¢metros fÃ­sicos, quÃ­micos e biolÃ³gicos. Para a Ã¡gua doce, em rios e lagos, sÃ£o definidas cinco classes de qualidade de Ã¡gua (classe especial, 1, 2, 3 e 4). A resoluÃ§Ã£o define limites individuais para mais de 90 parÃ¢metros e condiÃ§Ãµes que devem ser alcanÃ§ados em cada uma das classes. A classe especial Ã© uma exceÃ§Ã£o neste sentido, uma vez as condiÃ§Ãµes naturais da Ã¡gua em um trecho de classe especial devem ser mantidas independemente de parÃ¢metros preestablecidos com base nos usos.

    
O enquadramento dos corpos de Ã¡gua em classes de qualidade de acordo com os usos preponderantes pretendidos ocorre por meio de um processo participativo que culmina com a aprovaÃ§Ã£o das metas de qualidade pelos conselhos de recursos hÃ­dricos estaduais ou federal, dependendo da dominialidade do rio ou lago. Segundo a resoluÃ§Ã£o CONAMA nÂº 357/2005, enquanto nÃ£o aprovados os respectivos enquadramentos, as Ã¡guas doces serÃ£o consideradas classe 2, exceto se as condiÃ§Ãµes de qualidade atuais forem melhores, o que determinarÃ¡ a aplicaÃ§Ã£o da classe mais rigorosa correspondente.

O mapa abaixo mostra as classes de qualidade definidas pela resoluÃ§Ã£o CONAMA nÂº 357/2005 nos trechos onde se encontram os pontos de monitoramento das redes operadas pelas UFs. 


```{r enquadramento, echo=FALSE, collapse = TRUE, layout="l-body-outset", out.width = '100%'}
options(OutDec=",",  digits = "2")
# Importa tabela de pontos
pontos_sql <- paste("SELECT codigo, uf, latitude, longitude, enquadramento, corpo_hidrico FROM pgquali.qltft_1_pontos ORDER BY uf, codigo;", sep = "")
pontos <- dbGetQuery(con, pontos_sql)
coordenadas <- data.frame(
  CÃ³digo = c(pontos$codigo),
  UF = c(pontos$uf),
  lon = c(pontos$longitude[!is.na(pontos$longitude)]),
  lat = c(pontos$latitude[!is.na(pontos$latitude)]),
  classe = c(pontos$enquadramento),
  Rio = c(pontos$corpo_hidrico),
  stringsAsFactors = FALSE)

coordenadas <- st_as_sf(coordenadas, coords = c("lon", "lat"), crs = 4674) 

classes <- na.omit(coordenadas)

classes <- classes %>%
  mutate(Classe = case_when(
 classe == 12 ~ "NÃ£o enquadrado",
 classe == 0 ~ "Especial",
 classe == 1 ~ "Classe 1",
 classe == 2 ~ "Classe 2",
 classe == 3 ~ "Classe 3",
 classe == 4 ~ "Classe 4",
 classe == 99 ~ "Sem informaÃ§Ã£o",
 is.na(classe) ~ "Sem informaÃ§Ã£o"
  )
)

pal = colorRampPalette(c('light sky blue', 'lime green', 'orange', 'red', 'dodger blue', 'gainsboro', 'wheat'))
mapview(classes["Classe"], popup = popupTable(classes, zcol=c("CÃ³digo", "UF", "Rio", "Classe"), row.numbers=FALSE, feature.id=FALSE),
        #map.types = c("CartoDB.Positron", "Esri.WorldImagery"), 
        cex = 3, # tamanho dos markers 
        lwd = 0.2, #espessura da linha dos markers
        alpha.regions = 100, #opacidade dos markers
        legend = TRUE, 
        col.regions = (pal (7)),
        layer.name = "Classes de qualidade")

```
